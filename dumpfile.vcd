$date
	Thu Nov  1 17:07:08 2018
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module testbench $end
$scope module PE $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 1 # z $end
$var wire 16 $ result [15:0] $end
$var wire 16 % op2_12 [15:0] $end
$var wire 16 & ir_23 [15:0] $end
$var wire 16 ' ir_12 [15:0] $end
$var wire 16 ( ir_01 [15:0] $end
$var wire 1 ) haltedP $end
$var wire 16 * Rd_12 [15:0] $end
$var wire 16 + PCs4_to_reg [15:0] $end
$var wire 16 , PCfollow_23 [15:0] $end
$var wire 16 - PCfollow_12 [15:0] $end
$var wire 16 . PCfollow_01 [15:0] $end
$var reg 1 / halt $end
$scope module s0 $end
$var wire 16 0 R15 [15:0] $end
$var wire 1 ! clk $end
$var wire 1 1 insertNOP $end
$var wire 16 2 irInitial [15:0] $end
$var wire 1 " reset $end
$var wire 16 3 ir [15:0] $end
$var wire 1 ) halt $end
$var wire 1 # Z $end
$var wire 2 4 CC [1:0] $end
$var reg 16 5 PC [15:0] $end
$var reg 16 6 PCfollow [15:0] $end
$upscope $end
$scope module s1 $end
$var wire 16 7 Rd_out [15:0] $end
$var wire 1 ! clk $end
$var wire 16 8 ir [15:0] $end
$var wire 16 9 pc [15:0] $end
$var wire 1 " reset $end
$var wire 16 : pc_to_reg [15:0] $end
$var wire 5 ; op_code [4:0] $end
$var wire 16 < op2_out [15:0] $end
$var wire 1 = immFlag $end
$var wire 2 > cc [1:0] $end
$var wire 4 ? Rd [3:0] $end
$var reg 16 @ ir_out [15:0] $end
$var reg 16 A pc_follow [15:0] $end
$var reg 12 B pre [11:0] $end
$var reg 1 C preFlag $end
$upscope $end
$scope module s2 $end
$var wire 16 D addr [15:0] $end
$var wire 1 ! clk $end
$var wire 16 E data [15:0] $end
$var wire 16 F ir_in [15:0] $end
$var wire 16 G pc [15:0] $end
$var wire 1 " reset $end
$var wire 5 H op [4:0] $end
$var reg 16 I addr_latch [15:0] $end
$var reg 16 J data_latch [15:0] $end
$var reg 16 K ir_out [15:0] $end
$var reg 16 L pc_follow [15:0] $end
$var reg 16 M value_out [15:0] $end
$upscope $end
$scope module s3 $end
$var wire 1 ! clk $end
$var wire 16 N ir_in [15:0] $end
$var wire 16 O pc [15:0] $end
$var wire 1 " reset $end
$var wire 16 P result [15:0] $end
$var wire 2 Q cc [1:0] $end
$var wire 4 R Rd [3:0] $end
$var reg 5 S opcode [4:0] $end
$var reg 16 T pc_follow [15:0] $end
$var reg 1 # z_reg $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx T
bx S
bx R
bx Q
bx P
bx O
bx N
bx M
bx L
bx K
bx J
bx I
bx H
bx G
bx F
b0 E
b0 D
0C
b0 B
bx A
bx @
b0 ?
b1 >
1=
b0 <
b0 ;
bx :
bx 9
b1100000000 8
b0 7
bx 6
b0 5
b1 4
b1100000000 3
b1100000000 2
01
b0 0
0/
bx .
bx -
bx ,
bx +
b0 *
0)
b1100000000 (
bx '
bx &
b0 %
bx $
0#
0"
0!
$end
#10
1"
#20
0"
#30
b10100 ;
b0 >
0=
b0 4
b1010000000000000 (
b1010000000000000 3
b1010000000000000 8
b0 H
b1010000000000000 2
b1 5
b0 .
b0 6
b0 9
b1100000000 '
b1100000000 @
b1100000000 F
b0 I
b0 J
b0 $
b0 M
b0 P
1!
#40
0!
#50
b0 R
b1 Q
b10100 H
b1100000000 &
b1100000000 K
b1100000000 N
b1010000000000000 '
b1010000000000000 @
b1010000000000000 F
b0 -
b0 A
b0 G
b10 5
b1 .
b1 6
b1 9
1!
#60
0!
#70
b0 Q
b11 5
b10 .
b10 6
b10 9
b1 -
b1 A
b1 G
b1010000000000000 &
b1010000000000000 K
b1010000000000000 N
b0 ,
b0 L
b0 O
1#
b0 S
1!
#80
0!
#90
b0 %
b0 <
b0 E
11
b10100 ;
b0 >
0=
b0 ?
b11 4
b1010000000000000 (
b1010000000000000 3
b1010000000000000 8
b1 ,
b1 L
b1 O
b10 -
b10 A
b10 G
b11100010010 2
b100 5
b11 .
b11 6
b11 9
b10100 S
1!
#100
0!
#110
01
b0 4
b1010000000000000 2
b101 5
b100 .
b100 6
b100 9
b11 -
b11 A
b11 G
b10 ,
b10 L
b10 O
1!
#120
0!
#130
b11 ,
b11 L
b11 O
b100 -
b100 A
b100 G
b110 5
b101 .
b101 6
b101 9
1!
#140
0!
#150
b111 5
b110 .
b110 6
b110 9
b101 -
b101 A
b101 G
b100 ,
b100 L
b100 O
1!
#160
0!
#170
bx %
bx <
bx E
x1
x)
bx ;
bx >
x=
bx *
bx 7
bx D
bx ?
bx 4
bx (
bx 3
bx 8
b101 ,
b101 L
b101 O
b110 -
b110 A
b110 G
bx 2
b1000 5
b111 .
b111 6
b111 9
1!
#180
0!
#190
bx H
b1001 5
b1000 .
b1000 6
b1000 9
bx '
bx @
bx F
b111 -
b111 A
b111 G
b110 ,
b110 L
b110 O
bx I
bx J
x/
1!
#200
0!
